#CCNA  #TCPIP模型

# 傳輸層的協定
- 封包在網路層以下是不管有沒有傳送成功這件事；封包的可靠度就由傳輸層來確保
- 傳輸層同時也管理應用程式的開始連線跟結束連線

## 傳輸控制協定 (TCP)
- 常用應用有瀏覽器、e-mail 和 ftp …

### 特性
- **建立會談** - 確定應用程式準備好收資料了
- **可靠傳輸** - 遺失的資料段會重發；這是與 UDP 最重要的差異
- **同序處理** - 會依照標頭順序重組資料段
- **流量控制** - 網路擁塞的時候會要求來源端減少傳輸，避免資料段遺失重傳

### TCP 是怎麼做到上述特性的呢？
#### 建立會談
- TCP 可以追蹤實際對談的狀態，所以屬於狀態協定；也就是說，用 TCP 傳輸時，發出的請求（狀態）會被確認，如果沒有被確認，發送端就會認定接收端沒有收到資料，再重送一次資料
- 要連線的時候，先建立會談，如果對方回應了，再開始傳送資料；也就是所謂的[[CCNA/三向交握]]

#### 可靠性 - 依序傳送
- 資料段在網路傳輸的時候，會因為當下網路環境不同，路由器選擇不同的路由傳送資料，但是接收端在接收的時候還是有很大的可能，不是按照發送的順序收到封包
	1. 在會談建立時，會先設定一個初始序號 (ISN)；這個 ISN 表示會談中傳給應用程式的位元組起始值，在會談過程每傳一定位元組的資料，序號就隨之增加。透過這樣方式來追蹤資料位元及定位每個資料段， 還可以標識遺失的資料段
	2. 接收端的 TCP 程序會把資料存入快取區， 並按照資料段的順序做排序，重組後再傳給應用層
	3. 序號不連續的資料段會先保留，等到缺的資料段收到了，再來按順序處理

#### 可靠性 - 確認訊息和視窗大小
![](../img/Pasted%20image%2020201030102951.png)
-  TCP 用序列 (SEQ) 號及確認 (ACK) 號來確認收到的資料段有多少位元
	-  SEQ 表示這個會談中傳輸的相對位元數，包括目前資料段中的位元
	-  ACK 會再發回給來源端，用來指定接收端期望接收的下一位元；稱為期待確認
-  收到確認資訊後，來源端就可以得知接收端的資料收到哪一個位元（不包括 ACK 之後暫存的）；隨後，來源端就會繼續發送資料段，資料段的序號會等於該 ACK 號
> 別忘記，每個連線實際上都包含兩個單向會談， SEQ 號和 ACK 號雙向交換

#### 可靠性 - 資料遺失和重傳
- 接收端只會確認連續序號的資料；如果有資料段遺失，只會確認第一個連續的資料
	- 例如，如果收到序號為 1500 到 3000 和 3400 到 3500 的資料段，則 ACK 號為 3001；因為沒有收到 SEQ 號為 3001 到 3399 的資料
- 如果來源端的 TCP 在規定時間內沒有收到確認，就會從收到最後一個 ACK 號的地方開始向後重傳
	- 請求注解 (RFC) 中未對重新傳輸程序進行說明，這屬於 TCP 的特殊實作程序
- TCP 的標準實作程序
	1. 主機傳輸資料段，並複製一份副本到重新發送佇列，然後啟動計時器
	2. 當收到確認資訊時，就從佇列裡刪除相對應的資料段
	3. 如果計時器逾時還沒收到確認資訊，就重新傳輸資料段
- 現在的主機還擁有一項備選功能：選擇性確認 (SACK)
	- 如果兩台主機都支援 SACK 功能，接受端就可以確認間斷資料段中的資料，那來源端只要針對遺失的部分重傳就好

#### 流量控制 - 視窗大小和確認
![](../img/Pasted%20image%2020201030133103.png)
- TCP 在資料傳輸過程還可以視網路的狀況調整資料流速，來保持 TCP 的可靠性；方法包括限制一次可傳的流量及在要求更多資料前要先確認
- 要實作流量控制，TCP 首先要先確定接收端可以接受多少流量
	- 看 TCP 標頭的「視窗大小」來決定；在三向交握開始會談的時候，就可以確定初始視窗大小，來源端就會依照視窗大小的限制來切要發給接收端的封包
- 在等待接收確認前，來源端不會再發送資料。因為如果網路擁塞、或者接收端跑不動，延遲時間可能會更長。延遲時間越長，該會談的有效傳輸速率就越低；如果有多個會談時，減少每個會談的資料傳輸有助於減少網路和接收端的碰撞
- TCP 使用視窗大小嘗試管理傳輸速率，將其調整為網路和目的裝置可以支援的最大速度，同時最大限度減少損失和重新傳輸

#### 流量控制 - 避免擁塞
![](img/Pasted%20image%2020201030145913.png)如果資料有漏接受端會確認最後接收的連續資料段，同時在回覆時減少視窗大小



### TCP 的資料段長什麼樣？
![](../img/Pasted%20image%2020201029115115.png)
- **序號** - 32 位元，用來資料重組
- **確認號** - 32 位元，表示收到的資料
- **標頭長度** - 4 位元，稱為「資料偏移量」；表示 TCP 資料段標頭的長度
- **保留** - 6 位元
- **控制位元** - 6 位元，包括位元碼或旗標，表示 TCP 資料段的用途和功能
- **視窗大小** - 16 位元，表示接收端一次可以接受的資料段數量
- **總和檢查碼** - 16 位元，資料段標頭和資料的錯誤檢查用
-  **緊急** - 16 位元，表示資料是否緊急

### 使用 TCP 的應用程式
![](../img/Pasted%20image%2020201030152537.png)

## 使用者資料報協定 (UDP)
- UDP 與 TCP 就有如太陽與黑夜一樣，彼此截然不同，卻又不可卻缺
- 標頭比 TCP 短很多（只需要 8 位元），所以成本很小，傳輸速度快
- 常用應用有 DNS, VoIP，串流影音…

### 特性
- **非連接導向** - UDP 是不管接受方的，想傳就傳，有沒有收到就看緣份囉！
- **不可靠傳輸** - 就跟海角七號阿嘉送的信一樣，沒收到就沒囉
- **沒有循序的資料重構** - 順序是強迫症的人在意的事
- **無流量控制** - 超過負荷的封包我就丟丟丟，發送端也不需要再重傳了

### UDP 的資料段長什麼樣？
![](../img/Pasted%20image%2020201029134406.png)

### 使用 UDP 的應用程式
![](../img/Pasted%20image%2020201030152708.png)
- 有的程式使用 UDP 來獲得高速的傳輸速度，可靠性的問題就留到程式端來處理；如 TFTP 就是這樣的一個例子，它有自己的流量控制、錯誤檢測、確認和錯誤復原機制，不依靠 TCP 的服務

## 連接埠定址
### 傳輸層的協定有 TCP 與 UDP 同時存在，兩個不會打架嗎？
- 傳輸層用不同的連接埠來區分
- 在資料段或封包的標頭裡，都有來源連接埠和目的連接埠

### 來源連接埠號
- 本機的應用程式所使用的連接埠
- 由發送端隨機產生，用於標識兩台裝置之間的會談
- 使得多個會談能夠同時發生；換句話說，裝置可以同時發送多個 HTTP 服務要求到網頁伺服器，根據來源連接埠號可以追蹤每個單獨的會談

### 目的連接埠
- 遠端伺服器所提供服務的連接埠

### Socket
- 來源和目的 IP 位址，以及來源和目的連接埠號的組合
- 透過 IP 和連接埠的組合，就可以清楚辨識出和哪一支程式做構連

### 連接埠的分配

連接埠號 | 分類 | 說明
--- | --- | ---
0 - 1023 | 公認連接埠 | 分配給公認、常用的服務使用（常用的要記）
1024 - 49151 | 註冊連接埠 | 分配給使用者另外安裝的程式及服務使用
49152 到 65535 | 動態或私有連接埠 | 也叫臨時連接埠

- 動態或私有連接埠通常是用戶端有要連線的時候才會隨機分配，主要是拿來識別跟用戶端對接的應用程式
- 用公認連接埠來識別和連線時，一般很少會再另外分配臨時連接埠


### 小孩子才做選擇， TCP 跟 UDP 我都要可以嗎？
- 舉例來說，DNS 需要很快地回應很多用戶端的請求，這個需求可以透過低成本的 UDP 來達成，可是 DNS 又要定時查詢網域名稱，這就不用找隨性 UDP 做啦！收來的資料丟三拉四的怎麼辦，這時候又要可靠的 TCP 來做
- DNS 服務的 TCP 和 UDP 會同時用公認連接埠號 **53** 喔

### 我要怎麼知道我的電腦現在有哪些連線呢？
- 用`netstat`可以檢視本機所有正在連線的狀況
![](../img/Pasted%20image%2020201029212848.png)

